Env Meta: AAAAAAAAABYAAAAA
 â€¢ Protocol Version: 22

Contract Meta:
 â€¢ rsver: 1.90.0-nightly
 â€¢ rssdkver: 22.0.8#f46e9e0610213bbb72285566f9dd960ff96d03d8

Contract Spec:
 â€¢ Error: Error
     Cases:
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(OnlyCreatorCanAddGoals),
            value: 1,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyGoalContent),
            value: 2,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(CourseIdNotExist),
            value: 3,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(OnlyCreatorCanArchive),
            value: 4,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(CourseAlreadyArchived),
            value: 5,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(Unauthorized),
            value: 6,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(NameRequired),
            value: 7,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyCourseTitle),
            value: 8,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidPrice),
            value: 9,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(DuplicateCourseTitle),
            value: 10,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(DuplicateCourseId),
            value: 11,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(OnlyCreatorCanEditPrereqs),
            value: 12,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(PrereqCourseNotFound),
            value: 13,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(SelfPrerequisite),
            value: 14,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(CircularDependency),
            value: 15,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyCourseId),
            value: 16,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(CourseNotFound),
            value: 17,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyNewGoalContent),
            value: 18,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyGoalId),
            value: 19,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(GoalCourseMismatch),
            value: 20,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(ModuleNotFound),
            value: 21,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(UnauthorizedCaller),
            value: 401,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(UnauthorizedCourseAccess),
            value: 402,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidAdminOperation),
            value: 403,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyModuleTitle),
            value: 404,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(DuplicateModulePosition),
            value: 405,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyModuleId),
            value: 22,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(PrereqNotInList),
            value: 23,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidModulePosition),
            value: 24,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidModuleTitle),
            value: 25,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidCourseDescription),
            value: 26,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidCategoryName),
            value: 27,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyCategory),
            value: 28,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidTitleLength),
            value: 29,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidLanguageLength),
            value: 43,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidThumbnailUrlLength),
            value: 44,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidDurationValue),
            value: 45,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidLimitValue),
            value: 46,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidOffsetValue),
            value: 47,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidGoalContent),
            value: 48,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidPrerequisiteId),
            value: 49,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyPrerequisiteList),
            value: 50,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(TooManyPrerequisites),
            value: 51,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(EmptyPrerequisiteId),
            value: 52,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidCourseId),
            value: 53,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(InvalidPrice100),
            value: 54,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(AlreadyInitialized),
            value: 55,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(DuplicatePrerequisite),
            value: 56,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(CourseRateLimitExceeded),
            value: 57,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(CourseRateLimitNotConfigured),
            value: 58,
        }

 â€¢ Error: VersioningError
     Docs: Errors that can occur during contract versioning operations
     Cases:
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(Invalid version format),
            name: StringM(InvalidVersion),
            value: 1,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(Version not found in history),
            name: StringM(VersionNotFound),
            value: 2,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(Migration not compatible),
            name: StringM(MigrationNotCompatible),
            value: 3,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(Migration already completed),
            name: StringM(MigrationAlreadyCompleted),
            value: 4,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(Unauthorized migration attempt),
            name: StringM(UnauthorizedMigration),
            value: 5,
        }
      â€¢ ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(Migration failed),
            name: StringM(MigrationFailed),
            value: 6,
        }

 â€¢ Struct: CourseModule
     Fields:
      â€¢ course_id: String
      â€¢ created_at: U64
      â€¢ id: String
      â€¢ position: U32
      â€¢ title: String

 â€¢ Struct: CourseGoal
     Fields:
      â€¢ content: String
      â€¢ course_id: String
      â€¢ created_at: U64
      â€¢ created_by: Address
      â€¢ goal_id: String

 â€¢ Struct: CourseRateLimitConfig
     Docs: Rate limiting configuration for course operations.
          
          Tracks rate limiting settings for spam protection in course creation.
     Fields:
      â€¢ max_courses_per_window: U32
        StringM(Maximum course creations allowed per window)
      â€¢ window_seconds: U64
        StringM(Time window for rate limiting in seconds)

 â€¢ Struct: CourseRateLimitData
     Docs: Rate limiting tracking data for course operations per address.
          
          Stores the current usage count and window start time for course rate limiting.
     Fields:
      â€¢ count: U32
        StringM(Current count of course creations in this window)
      â€¢ window_start: U64
        StringM(Timestamp when the current window started)

 â€¢ Struct: CourseCategory
     Fields:
      â€¢ description: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )
      â€¢ id: U128
      â€¢ name: String

 â€¢ Union: DataKey
     Cases:
      â€¢ TupleV0(
            ScSpecUdtUnionCaseTupleV0 {
                doc: StringM(),
                name: StringM(Module),
                type_: VecM(
                    [
                        String,
                    ],
                ),
            },
        )
      â€¢ VoidV0(
            ScSpecUdtUnionCaseVoidV0 {
                doc: StringM(),
                name: StringM(Courses),
            },
        )
      â€¢ TupleV0(
            ScSpecUdtUnionCaseTupleV0 {
                doc: StringM(),
                name: StringM(CourseGoalList),
                type_: VecM(
                    [
                        String,
                    ],
                ),
            },
        )
      â€¢ TupleV0(
            ScSpecUdtUnionCaseTupleV0 {
                doc: StringM(),
                name: StringM(CourseGoal),
                type_: VecM(
                    [
                        String,
                        String,
                    ],
                ),
            },
        )
      â€¢ TupleV0(
            ScSpecUdtUnionCaseTupleV0 {
                doc: StringM(),
                name: StringM(CoursePrerequisites),
                type_: VecM(
                    [
                        String,
                    ],
                ),
            },
        )
      â€¢ VoidV0(
            ScSpecUdtUnionCaseVoidV0 {
                doc: StringM(),
                name: StringM(CategorySeq),
            },
        )
      â€¢ TupleV0(
            ScSpecUdtUnionCaseTupleV0 {
                doc: StringM(),
                name: StringM(CourseCategory),
                type_: VecM(
                    [
                        U128,
                    ],
                ),
            },
        )
      â€¢ VoidV0(
            ScSpecUdtUnionCaseVoidV0 {
                doc: StringM(),
                name: StringM(Admins),
            },
        )
      â€¢ VoidV0(
            ScSpecUdtUnionCaseVoidV0 {
                doc: StringM(Key for storing course rate limiting configuration),
                name: StringM(CourseRateLimitConfig),
            },
        )
      â€¢ TupleV0(
            ScSpecUdtUnionCaseTupleV0 {
                doc: StringM(Key for storing course rate limiting data per address: address -> CourseRateLimitData),
                name: StringM(CourseRateLimit),
                type_: VecM(
                    [
                        Address,
                    ],
                ),
            },
        )

 â€¢ Struct: Course
     Fields:
      â€¢ category: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )
      â€¢ creator: Address
      â€¢ description: String
      â€¢ duration_hours: Option(
            ScSpecTypeOption {
                value_type: U32,
            },
        )
      â€¢ id: String
      â€¢ is_archived: Bool
      â€¢ language: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )
      â€¢ level: Option(
            ScSpecTypeOption {
                value_type: Udt(
                    ScSpecTypeUdt {
                        name: StringM(CourseLevel),
                    },
                ),
            },
        )
      â€¢ prerequisites: Vec(
            ScSpecTypeVec {
                element_type: Udt(
                    ScSpecTypeUdt {
                        name: StringM(CourseId),
                    },
                ),
            },
        )
      â€¢ price: U128
      â€¢ published: Bool
      â€¢ thumbnail_url: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )
      â€¢ title: String

 â€¢ Struct: CourseId
     Fields:
      â€¢ count: U128
      â€¢ id: String

 â€¢ Struct: Category
     Fields:
      â€¢ count: U128
      â€¢ name: String

 â€¢ Struct: CourseFilters
     Fields:
      â€¢ category: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )
      â€¢ level: Option(
            ScSpecTypeOption {
                value_type: Udt(
                    ScSpecTypeUdt {
                        name: StringM(CourseLevel),
                    },
                ),
            },
        )
      â€¢ max_duration: Option(
            ScSpecTypeOption {
                value_type: U32,
            },
        )
      â€¢ max_price: Option(
            ScSpecTypeOption {
                value_type: U128,
            },
        )
      â€¢ min_duration: Option(
            ScSpecTypeOption {
                value_type: U32,
            },
        )
      â€¢ min_price: Option(
            ScSpecTypeOption {
                value_type: U128,
            },
        )
      â€¢ search_text: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )
        StringM(Text search in course title and description)

 â€¢ Struct: EditCourseParams
     Fields:
      â€¢ new_category: Option(
            ScSpecTypeOption {
                value_type: Option(
                    ScSpecTypeOption {
                        value_type: String,
                    },
                ),
            },
        )
      â€¢ new_description: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )
      â€¢ new_duration_hours: Option(
            ScSpecTypeOption {
                value_type: Option(
                    ScSpecTypeOption {
                        value_type: U32,
                    },
                ),
            },
        )
      â€¢ new_language: Option(
            ScSpecTypeOption {
                value_type: Option(
                    ScSpecTypeOption {
                        value_type: String,
                    },
                ),
            },
        )
      â€¢ new_level: Option(
            ScSpecTypeOption {
                value_type: Option(
                    ScSpecTypeOption {
                        value_type: Udt(
                            ScSpecTypeUdt {
                                name: StringM(CourseLevel),
                            },
                        ),
                    },
                ),
            },
        )
      â€¢ new_price: Option(
            ScSpecTypeOption {
                value_type: U128,
            },
        )
      â€¢ new_published: Option(
            ScSpecTypeOption {
                value_type: Bool,
            },
        )
      â€¢ new_thumbnail_url: Option(
            ScSpecTypeOption {
                value_type: Option(
                    ScSpecTypeOption {
                        value_type: String,
                    },
                ),
            },
        )
      â€¢ new_title: Option(
            ScSpecTypeOption {
                value_type: String,
            },
        )

 â€¢ Struct: CourseBackupData
     Docs: Backup data structure for course registry system.
          
          Contains all course data, categories, modules, goals, and prerequisites
          for backup and recovery operations.
     Fields:
      â€¢ admins: Vec(
            ScSpecTypeVec {
                element_type: Address,
            },
        )
        StringM(List of admin addresses)
      â€¢ backup_timestamp: U64
        StringM(Backup timestamp)
      â€¢ backup_version: String
        StringM(Backup version for compatibility)
      â€¢ categories: Map(
            ScSpecTypeMap {
                key_type: U128,
                value_type: Udt(
                    ScSpecTypeUdt {
                        name: StringM(CourseCategory),
                    },
                ),
            },
        )
        StringM(All course categories)
      â€¢ category_seq: U128
        StringM(Category sequence counter)
      â€¢ courses: Map(
            ScSpecTypeMap {
                key_type: String,
                value_type: Udt(
                    ScSpecTypeUdt {
                        name: StringM(Course),
                    },
                ),
            },
        )
        StringM(All courses in the system)
      â€¢ goals: Map(
            ScSpecTypeMap {
                key_type: String,
                value_type: Vec(
                    ScSpecTypeVec {
                        element_type: Udt(
                            ScSpecTypeUdt {
                                name: StringM(CourseGoal),
                            },
                        ),
                    },
                ),
            },
        )
        StringM(All course goals mapped by (course_id, goal_id))
      â€¢ modules: Map(
            ScSpecTypeMap {
                key_type: String,
                value_type: Udt(
                    ScSpecTypeUdt {
                        name: StringM(CourseModule),
                    },
                ),
            },
        )
        StringM(All course modules)
      â€¢ prerequisites: Map(
            ScSpecTypeMap {
                key_type: String,
                value_type: Vec(
                    ScSpecTypeVec {
                        element_type: Udt(
                            ScSpecTypeUdt {
                                name: StringM(CourseId),
                            },
                        ),
                    },
                ),
            },
        )
        StringM(Course prerequisites mapping)

 â€¢ Function: create_course
     Docs: Create a new course in the registry.
           
           This function creates a new course with the specified metadata and
           returns the created course object with a unique identifier.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `title` - The course title
           * `description` - The course description
           * `price` - The course price in the platform's currency
           * `category` - Optional course category
           * `language` - Optional course language
           * `thumbnail_url` - Optional URL for the course thumbnail image
           * `level` - Optional course difficulty level
           * `duration_hours` - Optional estimated duration in hours
           
           # Returns
           
           Returns the created `Course` object with all metadata and a unique ID.
           
           # Panics
           
           * If title or description are empty
           * If creator address is invalid
           * If price exceeds maximum allowed value
           
           # Examples
           
           ```rust
           let course = contract.create_course(
           env.clone(),
           instructor_address,
           "Rust Programming Basics".try_into().unwrap(),
           "Learn Rust from scratch".try_into().unwrap(),
           50
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(title),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(description),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(price),
                 type_: U128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(category),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: String,
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(language),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: String,
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(thumbnail_url),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: String,
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(level),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: Udt(
                             ScSpecTypeUdt {
                                 name: StringM(CourseLevel),
                             },
                         ),
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(duration_hours),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: U32,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(Course),
                 },
             ),
         ],
     )

 â€¢ Function: create_course_category
     Docs: Create a new course category.
           
           This function creates a new category that can be used to classify courses.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `caller` - The address of the user creating the category
           * `name` - The name of the category
           * `description` - Optional description of the category
           
           # Returns
           
           Returns the unique ID of the created category.
           
           # Panics
           
           * If category name is empty
           * If category with same name already exists
           
           # Examples
           
           ```rust
           // Create a programming category
           let category_id = contract.create_course_category(
           env.clone(),
           admin_address,
           "Programming".try_into().unwrap(),
           Some("Computer programming courses".try_into().unwrap())
           );
           ```
           
           # Edge Cases
           
           * **Duplicate names**: Cannot create categories with existing names
           * **Empty names**: Category name cannot be empty
           * **Unique IDs**: Each category gets a unique auto-generated ID
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(caller),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(name),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(description),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: String,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             U128,
         ],
     )

 â€¢ Function: get_course
     Docs: Retrieve a course by its ID.
           
           This function fetches a course's complete information using its unique identifier.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `course_id` - The unique identifier of the course to retrieve
           
           # Returns
           
           Returns the `Course` object containing all course metadata.
           
           # Panics
           
           * If course with given ID doesn't exist
           * If course_id is invalid or empty
           
           # Examples
           
           ```rust
           // Get course by ID
           let course = contract.get_course(env.clone(), "course_123".try_into().unwrap());
           println!("Course title: {}", course.title);
           ```
           
           # Edge Cases
           
           * **Non-existent course**: Will panic if course ID doesn't exist
           * **Archived courses**: Still retrievable but marked as archived
           * **Public access**: Anyone can retrieve course information
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(Course),
                 },
             ),
         ],
     )

 â€¢ Function: get_course_category
     Docs: Retrieve a course category by its ID.
           
           This function fetches a category's information using its unique identifier.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `category_id` - The unique identifier of the category to retrieve
           
           # Returns
           
           Returns `Some(CourseCategory)` if found, `None` if the category doesn't exist.
           
           # Examples
           
           ```rust
           // Get category by ID
           if let Some(category) = contract.get_course_category(env.clone(), 1) {
           println!("Category: {}", category.name);
           } else {
           println!("Category not found");
           }
           ```
           
           # Edge Cases
           
           * **Non-existent category**: Returns `None` instead of panicking
           * **Invalid ID**: Returns `None` for invalid category IDs
           * **Public access**: Anyone can retrieve category information
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(category_id),
                 type_: U128,
             },
         ],
     )
     Output: VecM(
         [
             Option(
                 ScSpecTypeOption {
                     value_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CourseCategory),
                         },
                     ),
                 },
             ),
         ],
     )

 â€¢ Function: get_courses_by_instructor
     Docs: Get all courses created by a specific instructor.
           
           This function retrieves all courses that were created by the specified instructor.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `instructor` - The address of the instructor to query courses for
           
           # Returns
           
           Returns a vector of `Course` objects created by the instructor.
           
           # Examples
           
           ```rust
           // Get all courses by an instructor
           let instructor_courses = contract.get_courses_by_instructor(env.clone(), instructor_address);
           for course in instructor_courses {
           println!("Course: {}", course.title);
           }
           ```
           
           # Edge Cases
           
           * **No courses**: Returns empty vector if instructor has no courses
           * **Archived courses**: Includes archived courses in results
           * **Public access**: Anyone can query instructor courses
           * **Invalid instructor**: Returns empty vector for non-existent instructors
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(instructor),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Vec(
                 ScSpecTypeVec {
                     element_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(Course),
                         },
                     ),
                 },
             ),
         ],
     )

 â€¢ Function: remove_module
     Docs: Remove a module from a course.
           
           This function removes a specific module from its associated course.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `module_id` - The unique identifier of the module to remove
           
           # Panics
           
           Remove a module from a course.
           
           This function removes a specific module from its associated course.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `module_id` - The unique identifier of the module to remove
           
           # Panics
           
           * If the module doesn't exist
           * If the module_id is invalid or empty
           * If module removal operation fails
           
           # Examples
           
           ```rust
           // Remove a module from a course
           contract.remove_module(env.clone(), "module_123".try_into().unwrap());
           ```
           
           # Edge Cases
           
           * **Non-existent module**: Will panic if module ID doesn't exist
           * **Invalid ID**: Will panic for invalid or empty module IDs
           * **Course updates**: Automatically updates course module count
           
           Panics if the module removal fails or if the module doesn't exist.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(module_id),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [],
     )

 â€¢ Function: add_module
     Docs: Add a new module to a course.
           
           This function creates and adds a new module to the specified course
           at the given position.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `course_id` - The unique identifier of the course to add the module to
           * `position` - The position where the module should be inserted
           * `title` - The title of the new module
           
           # Returns
           
           Returns the created `CourseModule` object.
           
           # Panics
           
           * If course doesn't exist
           * If caller is not the course creator
           * If module title is empty
           * If position is invalid
           
           # Examples
           
           ```rust
           // Add a module at position 1
           let module = contract.add_module(
           env.clone(),
           course_creator_address,
           "course_123".try_into().unwrap(),
           1,
           "Introduction to Variables".try_into().unwrap()
           );
           ```
           
           # Edge Cases
           
           * **Invalid position**: Position must be valid for the course
           * **Empty title**: Module title cannot be empty
           * **Creator only**: Only course creator can add modules
           * **Auto-generated ID**: Module gets unique auto-generated ID
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(caller),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(position),
                 type_: U32,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(title),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(CourseModule),
                 },
             ),
         ],
     )

 â€¢ Function: delete_course
     Docs: Delete a course from the registry.
           
           This function permanently removes a course from the registry.
           Only the course creator can delete their own courses.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course to delete
           
           # Panics
           
           * If course doesn't exist
           * If creator is not the actual course creator
           * If course_id is invalid or empty
           
           # Examples
           
           ```rust
           // Course creator deleting their course
           contract.delete_course(env.clone(), course_creator_address, "course_123".try_into().unwrap());
           ```
           
           # Edge Cases
           
           * **Permission denied**: Only course creator can delete their courses
           * **Non-existent course**: Will panic if course doesn't exist
           * **Permanent deletion**: Course and all associated data are permanently removed
           * **Enrolled students**: Consider impact on enrolled students before deletion
           
           Panics if the deletion fails or if the creator is not authorized.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [],
     )

 â€¢ Function: hello_world
     Docs: Simple hello world function for testing.
           
           This is a basic function that returns a greeting message,
           primarily used for testing contract deployment and basic functionality.
           
           # Arguments
           
           * `_env` - The Soroban environment (unused)
           
           # Returns
           
           Returns a greeting string.
           
           # Examples
           
           ```rust
           // Test contract deployment
           let greeting = contract.hello_world(env.clone());
           assert_eq!(greeting, "Hello from Web3 ðŸ‘‹");
           ```
           
           # Edge Cases
           
           * **Always succeeds**: This function never fails
           * **No dependencies**: Requires no external data or state
           * **Testing only**: Primarily intended for contract testing
     Inputs: VecM(
         [],
     )
     Output: VecM(
         [
             String,
         ],
     )

 â€¢ Function: edit_goal
     Docs: Edit an existing course goal.
           
           This function allows the course creator to modify the content of an existing goal.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course
           * `goal_id` - The unique identifier of the goal to edit
           * `new_content` - The new content for the goal
           
           # Returns
           
           Returns the updated `CourseGoal` object.
           
           # Panics
           
           * If course doesn't exist
           * If goal doesn't exist
           * If creator is not the course creator
           * If new_content is empty
           
           # Examples
           
           ```rust
           // Edit a course goal
           let updated_goal = contract.edit_goal(
           env.clone(),
           course_creator_address,
           "course_123".try_into().unwrap(),
           "goal_456".try_into().unwrap(),
           "Updated learning objective".try_into().unwrap()
           );
           ```
           
           # Edge Cases
           
           * **Empty content**: New content cannot be empty
           * **Creator only**: Only course creator can edit goals
           * **Non-existent goal**: Will panic if goal ID doesn't exist
           * **Content validation**: New content must meet validation
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(goal_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(new_content),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(CourseGoal),
                 },
             ),
         ],
     )

 â€¢ Function: add_goal
     Docs: Add a new goal to a course.
           
           This function creates and adds a new learning goal to the specified course.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course
           * `content` - The content/description of the goal
           
           # Returns
           
           Returns the created `CourseGoal` object.
           
           # Panics
           
           * If course doesn't exist
           * If creator is not the course creator
           * If content is empty
           
           # Examples
           
           ```rust
           // Add a learning goal to a course
           let goal = contract.add_goal(
           env.clone(),
           course_creator_address,
           "course_123".try_into().unwrap(),
           "Students will learn basic programming concepts".try_into().unwrap()
           );
           ```
           
           # Edge Cases
           
           * **Empty content**: Goal content cannot be empty
           * **Creator only**: Only course creator can add goals
           * **Auto-generated ID**: Goal gets unique auto-generated ID
           * **Content validation**: Goal content must meet validation requirements
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(content),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(CourseGoal),
                 },
             ),
         ],
     )

 â€¢ Function: remove_goal
     Docs: Remove a goal from a course.
           
           This function removes a specific learning goal from the course.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `caller` - The address of the user requesting the removal
           * `course_id` - The unique identifier of the course
           * `goal_id` - The unique identifier of the goal to remove
           
           # Panics
           
           * If course doesn't exist
           * If goal doesn't exist
           * If caller is not the course creator
           
           # Examples
           
           ```rust
           // Remove a goal from a course
           contract.remove_goal(
           env.clone(),
           course_creator_address,
           "course_123".try_into().unwrap(),
           "goal_456".try_into().unwrap()
           );
           ```
           
           # Edge Cases
           
           * **Creator only**: Only course creator can remove goals
           * **Non-existent goal**: Will panic if goal ID doesn't exist
           * **Permanent removal**: Goal is permanently deleted from course
           * **Goal count**: Automatically updates course goal count
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(caller),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(goal_id),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [],
     )

 â€¢ Function: add_prerequisite
     Docs: Add prerequisites to a course.
           
           This function adds prerequisite courses that must be completed
           before a student can enroll in the target course.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course
           * `prerequisite_course_ids` - Vector of course IDs that are prerequisites
           
           # Panics
           
           * If course doesn't exist
           * If creator is not the course creator
           * If any prerequisite course doesn't exist
           * If trying to add self as prerequisite
           
           # Examples
           
           ```rust
           let mut prerequisites = Vec::new(&env);
           prerequisites.push_back("basic_rust".try_into().unwrap());
           prerequisites.push_back("programming_fundamentals".try_into().unwrap());
           
           contract.add_prerequisite(
           env.clone(),
           course_creator_address,
           "advanced_rust".try_into().unwrap(),
           prerequisites
           );
           ```
           
           # Edge Cases
           
           * **Circular dependencies**: Cannot add self as prerequisite
           * **Non-existent courses**: All prerequisite courses must exist
           * **Creator only**: Only course creator ca
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(prerequisite_course_ids),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: String,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [],
     )

 â€¢ Function: remove_prerequisite
     Docs: Remove a prerequisite from a course.
           
           This function removes a specific prerequisite course requirement
           from the target course.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course
           * `prerequisite_course_id` - The ID of the prerequisite course to remove
           
           # Panics
           
           * If course doesn't exist
           * If creator is not the course creator
           * If prerequisite doesn't exist for the course
           
           # Examples
           
           ```rust
           // Remove a prerequisite from a course
           contract.remove_prerequisite(
           env.clone(),
           course_creator_address,
           "advanced_rust".try_into().unwrap(),
           "basic_rust".try_into().unwrap()
           );
           ```
           
           # Edge Cases
           
           * **Non-existent prerequisite**: Will panic if prerequisite doesn't exist
           * **Creator only**: Only course creator can remove prerequisites
           * **No effect**: Removing non-existent prerequisite has no effect
           * **Student impact**: Consider impact on enrolled students
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(prerequisite_course_id),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [],
     )

 â€¢ Function: edit_prerequisite
     Docs: Edit the prerequisites for a course.
           
           This function replaces all existing prerequisites with a new set
           of prerequisite courses.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course
           * `new_prerequisites` - Vector of new prerequisite course IDs
           
           # Panics
           
           * If course doesn't exist
           * If creator is not the course creator
           * If any prerequisite course doesn't exist
           * If trying to add self as prerequisite
           
           # Examples
           
           ```rust
           let mut new_prerequisites = Vec::new(&env);
           new_prerequisites.push_back("updated_course_1".try_into().unwrap());
           new_prerequisites.push_back("updated_course_2".try_into().unwrap());
           
           contract.edit_prerequisite(
           env.clone(),
           course_creator_address,
           "target_course".try_into().unwrap(),
           new_prerequisites
           );
           ```
           
           # Edge Cases
           
           * **Complete replacement**: All old prerequisites are removed
           * **Empty vector**: Can clear all prerequisites with empty vector
           * **Circular dependencies**: Cannot add self as prere
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(new_prerequisites),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: String,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [],
     )

 â€¢ Function: edit_course
     Docs: Edit course information.
           
           This function allows the course creator to update various aspects
           of the course using the provided parameters.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course to edit
           * `params` - Parameters containing the fields to update
           
           # Returns
           
           Returns the updated `Course` object.
           
           # Panics
           
           * If course doesn't exist
           * If creator is not the course creator
           * If any field validation fails
           
           # Examples
           
           ```rust
           let params = EditCourseParams {
           title: Some("Updated Course Title".try_into().unwrap()),
           description: Some("Updated description".try_into().unwrap()),
           price: Some(7500),
           level: Some(CourseLevel::Intermediate),
           ..Default::default()
           };
           
           let updated_course = contract.edit_course(
           env.clone(),
           course_creator_address,
           "course_123".try_into().unwrap(),
           params
           );
           ```
           
           # Edge Cases
           
           * **Partial updates**: Only provided fields are updated
           * **Validation**: All fields must pass validation rules
           * **Cre
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(params),
                 type_: Udt(
                     ScSpecTypeUdt {
                         name: StringM(EditCourseParams),
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(Course),
                 },
             ),
         ],
     )

 â€¢ Function: archive_course
     Docs: Archive a course.
           
           This function marks a course as archived, making it unavailable for new enrollments
           while preserving existing data and access for current students.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `creator` - The address of the course creator
           * `course_id` - The unique identifier of the course to archive
           
           # Returns
           
           Returns the updated `Course` object with archived status.
           
           # Panics
           
           * If course doesn't exist
           * If creator is not the course creator
           * If course is already archived
           
           # Examples
           
           ```rust
           // Archive a course
           let archived_course = contract.archive_course(
           &env,
           course_creator_address,
           "course_123".try_into().unwrap()
           );
           ```
           
           # Edge Cases
           
           * **Already archived**: Will panic if course is already archived
           * **Creator only**: Only course creator can archive course
           * **Student access**: Current students retain access
           * **Reversible**: Course can be unarchived if needed
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(creator),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(Course),
                 },
             ),
         ],
     )

 â€¢ Function: is_course_creator
     Docs: Check if a user is the creator of a specific course.
           
           This function verifies whether the specified user is the original creator
           of the given course.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `course_id` - The unique identifier of the course
           * `user` - The address of the user to check
           
           # Returns
           
           Returns `true` if the user is the course creator, `false` otherwise.
           
           # Panics
           
           * If course doesn't exist
           
           # Examples
           
           ```rust
           // Check if user is course creator
           let is_creator = contract.is_course_creator(
           &env,
           "course_123".try_into().unwrap(),
           user_address
           );
           
           if is_creator {
           // User can edit this course
           }
           ```
           
           # Edge Cases
           
           * **Non-existent course**: Will panic if course doesn't exist
           * **Public access**: Anyone can check creator status
           * **Creator verification**: Useful for permission checks
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(course_id),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(user),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Bool,
         ],
     )

 â€¢ Function: list_categories
     Docs: List all available course categories.
           
           This function retrieves all course categories that have been created
           in the system.
           
           # Arguments
           
           * `env` - The Soroban environment
           
           # Returns
           
           Returns a vector of all available `Category` objects.
           
           # Examples
           
           ```rust
           // Get all categories
           let categories = contract.list_categories(env.clone());
           for category in categories {
           println!("Category: {}", category.name);
           }
           ```
           
           # Edge Cases
           
           * **Empty system**: Returns empty vector if no categories exist
           * **Public access**: Anyone can list categories
           * **Order**: Categories are returned in creation order
     Inputs: VecM(
         [],
     )
     Output: VecM(
         [
             Vec(
                 ScSpecTypeVec {
                     element_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(Category),
                         },
                     ),
                 },
             ),
         ],
     )

 â€¢ Function: list_courses_with_filters
     Docs: List courses with filtering and pagination.
           
           This function retrieves courses based on the provided filters
           with optional pagination support.
           
           # Arguments
           
           * `env` - The Soroban environment
           * `filters` - Filtering criteria for courses
           * `limit` - Optional maximum number of courses to return
           * `offset` - Optional number of courses to skip for pagination
           
           # Returns
           
           Returns a vector of `Course` objects matching the filter criteria.
           
           # Examples
           
           ```rust
           // List first 10 courses
           let courses = contract.list_courses_with_filters(
           env.clone(),
           CourseFilters::default(),
           Some(10),
           Some(0)
           );
           
           // Filter by category
           let mut filters = CourseFilters::default();
           filters.category = Some("Programming".try_into().unwrap());
           let programming_courses = contract.list_courses_with_filters(
           env.clone(),
           filters,
           Some(20),
           None
           );
           ```
           
           # Edge Cases
           
           * **No matches**: Returns empty vector if no courses match filters
           * **Large limits**: Limit should be reasonable to avoid gas issues
           * **Public access**: Anyone can list courses
           * **Arch
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(filters),
                 type_: Udt(
                     ScSpecTypeUdt {
                         name: StringM(CourseFilters),
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(limit),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: U32,
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(offset),
                 type_: Option(
                     ScSpecTypeOption {
                         value_type: U32,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             Vec(
                 ScSpecTypeVec {
                     element_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(Course),
                         },
                     ),
                 },
             ),
         ],
     )

 â€¢ Function: export_course_data
     Docs: Export all course data for backup purposes (admin only)
           
           This function exports all course data including courses, categories,
           modules, goals, and prerequisites for backup and recovery purposes.
           
           # Arguments
           * `env` - Soroban environment
           * `caller` - Address performing the export (must be admin)
           
           # Returns
           * `CourseBackupData` - Complete backup data structure
           
           # Panics
           * If caller is not an admin
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(caller),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Udt(
                 ScSpecTypeUdt {
                     name: StringM(CourseBackupData),
                 },
             ),
         ],
     )

 â€¢ Function: import_course_data
     Docs: Import course data from backup (admin only)
           
           This function imports course data from a backup structure.
           Only admins can perform this operation. This will overwrite existing data.
           
           # Arguments
           * `env` - Soroban environment
           * `caller` - Address performing the import (must be admin)
           * `backup_data` - Backup data structure to import
           
           # Returns
           * `u32` - Number of courses imported
           
           # Panics
           * If caller is not an admin
           * If backup data is invalid
           * If import operation fails
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(caller),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(backup_data),
                 type_: Udt(
                     ScSpecTypeUdt {
                         name: StringM(CourseBackupData),
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             U32,
         ],
     )

 â€¢ Function: get_contract_version
     Docs: Get the current contract version
           
           Returns the semantic version of the current contract deployment.
           This is useful for tracking contract upgrades and compatibility.
           
           # Arguments
           * `_env` - The Soroban environment (unused)
           
           # Returns
           * `String` - The current contract version
     Inputs: VecM(
         [],
     )
     Output: VecM(
         [
             String,
         ],
     )

 â€¢ Function: get_version_history
     Docs: Get contract version history
           
           Returns a list of all versions that have been deployed for this contract.
           This helps track the evolution of the contract over time.
           
           # Arguments
           * `env` - The Soroban environment
           
           # Returns
           * `Vec<String>` - Vector of version strings in chronological order
     Inputs: VecM(
         [],
     )
     Output: VecM(
         [
             Vec(
                 ScSpecTypeVec {
                     element_type: String,
                 },
             ),
         ],
     )

 â€¢ Function: is_version_compatible
     Docs: Check compatibility between contract versions
           
           Determines if data from one version can be safely used with another version.
           This is crucial for migration processes and backward compatibility.
           
           # Arguments
           * `env` - The Soroban environment
           * `from_version` - The source version to check compatibility from
           * `to_version` - The target version to check compatibility to
           
           # Returns
           * `bool` - True if the versions are compatible, false otherwise
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(from_version),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(to_version),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [
             Bool,
         ],
     )

 â€¢ Function: migrate_course_data
     Docs: Migrate course data between contract versions
           
           Performs data migration from one contract version to another.
           This function handles the transformation of course data structures
           when upgrading contract versions.
           
           # Arguments
           * `env` - The Soroban environment
           * `caller` - The address performing the migration (must be course creator or admin)
           * `from_version` - The source version to migrate from
           * `to_version` - The target version to migrate to
           
           # Returns
           * `bool` - True if migration was successful, false otherwise
           
           # Events
           Emits a migration event upon successful completion
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(caller),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(from_version),
                 type_: String,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(to_version),
                 type_: String,
             },
         ],
     )
     Output: VecM(
         [
             Bool,
         ],
     )

 â€¢ Function: get_migration_status
     Docs: Get migration status for the current contract
           
           Returns information about the current migration status and any
           pending migrations that need to be completed.
           
           # Arguments
           * `env` - The Soroban environment
           
           # Returns
           * `String` - Migration status information
     Inputs: VecM(
         [],
     )
     Output: VecM(
         [
             String,
         ],
     )


